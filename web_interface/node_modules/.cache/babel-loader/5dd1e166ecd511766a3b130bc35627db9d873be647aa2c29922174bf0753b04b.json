{"ast":null,"code":"// Minimum image requirements\nconst MIN_WIDTH=800;const MIN_HEIGHT=600;const MAX_FILE_SIZE=10*1024*1024;// 10MB\n/**\n * Validates an uploaded image file\n */export async function validateImage(file){const errors=[];const warnings=[];// Check file type\nif(!file.type.startsWith('image/jpeg')){errors.push('Only JPEG images are supported');return{isValid:false,errors,warnings};}// Check file size\nif(file.size>MAX_FILE_SIZE){errors.push(\"File size must be less than \".concat(MAX_FILE_SIZE/(1024*1024),\"MB\"));}// Check image dimensions and quality\ntry{const dimensions=await getImageDimensions(file);if(dimensions.width<MIN_WIDTH||dimensions.height<MIN_HEIGHT){errors.push(\"Image must be at least \".concat(MIN_WIDTH,\"x\").concat(MIN_HEIGHT,\" pixels\"));}// Check aspect ratio (should be reasonable for book spines)\nconst aspectRatio=dimensions.width/dimensions.height;if(aspectRatio<0.5||aspectRatio>3){warnings.push('Unusual aspect ratio - may affect spine detection accuracy');}// Check for potential blur (simple edge detection simulation)\nconst blurScore=await checkImageBlur(file);if(blurScore<0.1){errors.push('Image appears to be very blurry - please use a sharper image for best results');}else if(blurScore<0.3){warnings.push('Image quality could be improved, but should still work');}}catch(error){errors.push('Failed to analyze image - file may be corrupted');}return{isValid:errors.length===0,errors,warnings};}/**\n * Gets image dimensions from a file\n */async function getImageDimensions(file){return new Promise((resolve,reject)=>{const img=new Image();img.onload=()=>{resolve({width:img.width,height:img.height});};img.onerror=()=>reject(new Error('Failed to load image'));img.src=URL.createObjectURL(file);});}/**\n * Simple blur detection using canvas\n */async function checkImageBlur(file){return new Promise(resolve=>{const canvas=document.createElement('canvas');const ctx=canvas.getContext('2d');const img=new Image();img.onload=()=>{canvas.width=img.width;canvas.height=img.height;if(ctx){ctx.drawImage(img,0,0);const imageData=ctx.getImageData(0,0,canvas.width,canvas.height);const blurScore=calculateBlurScore(imageData);resolve(blurScore);}else{resolve(0.5);// Default score if canvas context not available\n}};img.onerror=()=>resolve(0.5);// Default score on error\nimg.src=URL.createObjectURL(file);});}/**\n * Calculate blur score using Laplacian variance\n */function calculateBlurScore(imageData){const{data,width,height}=imageData;let variance=0;let count=0;// Simple edge detection using Laplacian operator\nfor(let y=1;y<height-1;y++){for(let x=1;x<width-1;x++){const idx=(y*width+x)*4;const center=data[idx];// Laplacian kernel: [[0,1,0], [1,-4,1], [0,1,0]]\nconst laplacian=data[((y-1)*width+x)*4]+// top\ndata[((y+1)*width+x)*4]+// bottom\ndata[(y*width+(x-1))*4]+// left\ndata[(y*width+(x+1))*4]-// right\n4*center;// center * -4\nvariance+=laplacian*laplacian;count++;}}const avgVariance=variance/count;// Normalize to 0-1 range (higher = sharper)\n// This is a simplified approach - in production you'd want more sophisticated blur detection\nlet normalizedScore=Math.min(avgVariance/500,1.0);// Ensure minimum score for images that might have low variance but are still sharp\n// This prevents false rejections of good quality images\nnormalizedScore=Math.max(normalizedScore,0.2);return normalizedScore;}/**\n * Process image through the Spinecat pipeline\n * This will be replaced with actual pipeline integration\n */export async function processImage(file){// TODO: Integrate with actual pipeline\n// For now, return a promise that resolves after a delay\nreturn new Promise(resolve=>{setTimeout(()=>{resolve({success:true,message:'Image processed successfully'});},2000);});}","map":{"version":3,"names":["MIN_WIDTH","MIN_HEIGHT","MAX_FILE_SIZE","validateImage","file","errors","warnings","type","startsWith","push","isValid","size","concat","dimensions","getImageDimensions","width","height","aspectRatio","blurScore","checkImageBlur","error","length","Promise","resolve","reject","img","Image","onload","onerror","Error","src","URL","createObjectURL","canvas","document","createElement","ctx","getContext","drawImage","imageData","getImageData","calculateBlurScore","data","variance","count","y","x","idx","center","laplacian","avgVariance","normalizedScore","Math","min","max","processImage","setTimeout","success","message"],"sources":["C:/Users/coope/CursorWorkspace/Spinecat/web_interface/src/utils/imageUtils.ts"],"sourcesContent":["import { ImageValidationResult } from '../types';\n\n// Minimum image requirements\nconst MIN_WIDTH = 800;\nconst MIN_HEIGHT = 600;\nconst MAX_FILE_SIZE = 10 * 1024 * 1024; // 10MB\n\n/**\n * Validates an uploaded image file\n */\nexport async function validateImage(file: File): Promise<ImageValidationResult> {\n  const errors: string[] = [];\n  const warnings: string[] = [];\n\n  // Check file type\n  if (!file.type.startsWith('image/jpeg')) {\n    errors.push('Only JPEG images are supported');\n    return { isValid: false, errors, warnings };\n  }\n\n  // Check file size\n  if (file.size > MAX_FILE_SIZE) {\n    errors.push(`File size must be less than ${MAX_FILE_SIZE / (1024 * 1024)}MB`);\n  }\n\n  // Check image dimensions and quality\n  try {\n    const dimensions = await getImageDimensions(file);\n    \n    if (dimensions.width < MIN_WIDTH || dimensions.height < MIN_HEIGHT) {\n      errors.push(`Image must be at least ${MIN_WIDTH}x${MIN_HEIGHT} pixels`);\n    }\n\n    // Check aspect ratio (should be reasonable for book spines)\n    const aspectRatio = dimensions.width / dimensions.height;\n    if (aspectRatio < 0.5 || aspectRatio > 3) {\n      warnings.push('Unusual aspect ratio - may affect spine detection accuracy');\n    }\n\n    // Check for potential blur (simple edge detection simulation)\n    const blurScore = await checkImageBlur(file);\n    if (blurScore < 0.1) {\n      errors.push('Image appears to be very blurry - please use a sharper image for best results');\n    } else if (blurScore < 0.3) {\n      warnings.push('Image quality could be improved, but should still work');\n    }\n\n  } catch (error) {\n    errors.push('Failed to analyze image - file may be corrupted');\n  }\n\n  return {\n    isValid: errors.length === 0,\n    errors,\n    warnings\n  };\n}\n\n/**\n * Gets image dimensions from a file\n */\nasync function getImageDimensions(file: File): Promise<{ width: number; height: number }> {\n  return new Promise((resolve, reject) => {\n    const img = new Image();\n    img.onload = () => {\n      resolve({ width: img.width, height: img.height });\n    };\n    img.onerror = () => reject(new Error('Failed to load image'));\n    img.src = URL.createObjectURL(file);\n  });\n}\n\n/**\n * Simple blur detection using canvas\n */\nasync function checkImageBlur(file: File): Promise<number> {\n  return new Promise((resolve) => {\n    const canvas = document.createElement('canvas');\n    const ctx = canvas.getContext('2d');\n    const img = new Image();\n    \n    img.onload = () => {\n      canvas.width = img.width;\n      canvas.height = img.height;\n      \n      if (ctx) {\n        ctx.drawImage(img, 0, 0);\n        const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);\n        const blurScore = calculateBlurScore(imageData);\n        resolve(blurScore);\n      } else {\n        resolve(0.5); // Default score if canvas context not available\n      }\n    };\n    \n    img.onerror = () => resolve(0.5); // Default score on error\n    img.src = URL.createObjectURL(file);\n  });\n}\n\n/**\n * Calculate blur score using Laplacian variance\n */\nfunction calculateBlurScore(imageData: ImageData): number {\n  const { data, width, height } = imageData;\n  let variance = 0;\n  let count = 0;\n\n  // Simple edge detection using Laplacian operator\n  for (let y = 1; y < height - 1; y++) {\n    for (let x = 1; x < width - 1; x++) {\n      const idx = (y * width + x) * 4;\n      const center = data[idx];\n      \n      // Laplacian kernel: [[0,1,0], [1,-4,1], [0,1,0]]\n      const laplacian = \n        data[((y-1) * width + x) * 4] +     // top\n        data[((y+1) * width + x) * 4] +     // bottom\n        data[(y * width + (x-1)) * 4] +     // left\n        data[(y * width + (x+1)) * 4] -     // right\n        4 * center;                          // center * -4\n      \n      variance += laplacian * laplacian;\n      count++;\n    }\n  }\n\n  const avgVariance = variance / count;\n  \n  // Normalize to 0-1 range (higher = sharper)\n  // This is a simplified approach - in production you'd want more sophisticated blur detection\n  let normalizedScore = Math.min(avgVariance / 500, 1.0);\n  \n  // Ensure minimum score for images that might have low variance but are still sharp\n  // This prevents false rejections of good quality images\n  normalizedScore = Math.max(normalizedScore, 0.2);\n  \n  return normalizedScore;\n}\n\n/**\n * Process image through the Spinecat pipeline\n * This will be replaced with actual pipeline integration\n */\nexport async function processImage(file: File): Promise<any> {\n  // TODO: Integrate with actual pipeline\n  // For now, return a promise that resolves after a delay\n  return new Promise((resolve) => {\n    setTimeout(() => {\n      resolve({\n        success: true,\n        message: 'Image processed successfully'\n      });\n    }, 2000);\n  });\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}