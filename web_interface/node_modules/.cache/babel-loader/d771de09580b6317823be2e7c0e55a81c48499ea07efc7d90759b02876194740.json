{"ast":null,"code":"const API_BASE_URL = process.env.REACT_APP_API_URL || 'http://localhost:8000';\nclass ApiService {\n  constructor() {\n    this.baseUrl = void 0;\n    this.baseUrl = 'http://127.0.0.1:8002'; // Updated to use port 8002\n  }\n\n  /**\n   * Check if the backend is healthy and ready\n   */\n  async checkHealth() {\n    try {\n      const response = await fetch(`${this.baseUrl}/health`);\n      if (!response.ok) {\n        throw new Error(`HTTP error! status: ${response.status}`);\n      }\n      return await response.json();\n    } catch (error) {\n      console.error('Health check failed:', error);\n      throw new Error('Backend is not available');\n    }\n  }\n\n  /**\n   * Test API connectivity\n   */\n  async testConnection(file) {\n    try {\n      console.log('ðŸ§ª API: Testing connection...');\n      const formData = new FormData();\n      formData.append('file', file);\n      const response = await fetch(`${this.baseUrl}/api/test`, {\n        method: 'POST',\n        body: formData\n      });\n      console.log('ðŸ§ª API: Test response:', response.status, response.statusText);\n      if (!response.ok) {\n        throw new Error(`Test failed! status: ${response.status}`);\n      }\n      const result = await response.json();\n      console.log('ðŸ§ª API: Test result:', result);\n      return result;\n    } catch (error) {\n      console.error('ðŸ§ª API: Test failed:', error);\n      throw error;\n    }\n  }\n\n  /**\n   * Process an uploaded image through the Spinecat pipeline\n   */\n  async processImage(file) {\n    try {\n      console.log('ðŸš€ API: Starting processImage...');\n      console.log('ðŸš€ API: baseUrl:', this.baseUrl);\n      console.log('ðŸš€ API: file:', file.name, file.size, file.type);\n      const formData = new FormData();\n      formData.append('file', file);\n      console.log('ðŸš€ API: Making fetch request to:', `${this.baseUrl}/api/process-image`);\n      const response = await fetch(`${this.baseUrl}/api/process-image`, {\n        method: 'POST',\n        body: formData\n      });\n      console.log('ðŸš€ API: Response received:', response.status, response.statusText);\n      if (!response.ok) {\n        const errorData = await response.json();\n        throw new Error(errorData.detail || `HTTP error! status: ${response.status}`);\n      }\n      const result = await response.json();\n\n      // Debug logging\n      console.log('Backend API response:', result);\n      console.log('Spine regions from backend:', result.spine_regions);\n\n      // Convert the API response to our frontend types\n      const convertedResult = {\n        image_url: URL.createObjectURL(file),\n        total_spines: result.total_spines,\n        successful_matches: result.successful_matches,\n        perfect_matches: result.successful_matches,\n        spine_regions: result.spine_regions.map(spine => {\n          // Debug logging for each spine\n          console.log('Processing spine:', spine);\n          console.log('Spine bbox:', spine.bbox);\n          const bbox = spine.bbox || [];\n          let x = 0,\n            y = 0,\n            width = 0,\n            height = 0,\n            rotation = 0;\n          if (bbox.length >= 8) {\n            const xCoords = [bbox[0], bbox[2], bbox[4], bbox[6]];\n            const yCoords = [bbox[1], bbox[3], bbox[5], bbox[7]];\n            x = Math.min(...xCoords);\n            y = Math.min(...yCoords);\n            width = Math.max(...xCoords) - x;\n            height = Math.max(...yCoords) - y;\n            if (bbox.length >= 4) {\n              const dx = bbox[2] - bbox[0];\n              const dy = bbox[3] - bbox[1];\n              rotation = Math.atan2(dy, dx) * (180 / Math.PI);\n            }\n            console.log('Converted coordinates:', {\n              x,\n              y,\n              width,\n              height,\n              rotation\n            });\n          } else {\n            console.log('Invalid bbox length:', bbox.length);\n          }\n          const convertedSpine = {\n            id: spine.id,\n            x: x,\n            y: y,\n            width: width,\n            height: height,\n            rotation: rotation,\n            confidence: spine.confidence,\n            coordinates: bbox.length >= 8 ? [[bbox[0], bbox[1]], [bbox[2], bbox[3]], [bbox[4], bbox[5]], [bbox[6], bbox[7]]] : [],\n            ocr_text: spine.ocr_text || \"No OCR text available\",\n            denoised_text: spine.denoised_text || \"No denoised text available\"\n          };\n          console.log('Converted spine:', convertedSpine);\n          return convertedSpine;\n        }),\n        book_matches: result.book_matches.map(match => ({\n          id: match.spine_id || `match_${Math.random()}`,\n          title: match.title || \"\",\n          author_name: match.author ? [match.author] : [],\n          first_publish_year: match.year ? parseInt(match.year) : null,\n          publisher: \"\",\n          match_score: match.confidence || 0,\n          match_type: match.confidence > 0.8 ? 'exact' : match.confidence > 0.6 ? 'strong' : match.confidence > 0.4 ? 'moderate' : 'weak',\n          confidence: match.confidence || 0,\n          ocr_text: match.ocr_text || \"No OCR text available\",\n          spine_region_id: match.spine_id || \"\",\n          open_library_id: match.open_library_id || \"\"\n        })),\n        ocr_failures: result.ocr_failures.map(failure => ({\n          id: failure.spine_id,\n          spine_id: failure.spine_id,\n          bbox: failure.bbox,\n          confidence: failure.confidence,\n          error_type: failure.error_type || \"no_text_detected\",\n          message: failure.message || \"No text could be extracted from this spine region\"\n        })),\n        processing_time: result.processing_time\n      };\n\n      // Debug logging for final result\n      console.log('Final converted spine regions:', convertedResult.spine_regions.map(spine => ({\n        id: spine.id,\n        x: spine.x,\n        y: spine.y,\n        width: spine.width,\n        height: spine.height\n      })));\n      return convertedResult;\n    } catch (error) {\n      console.error('Image processing failed:', error);\n      throw error;\n    }\n  }\n\n  /**\n   * Search for books using the Open Library API\n   */\n  async searchBooks(query, limit = 5) {\n    try {\n      const response = await fetch(`${this.baseUrl}/api/search-books?query=${encodeURIComponent(query)}&limit=${limit}`);\n      if (!response.ok) {\n        const errorData = await response.json();\n        throw new Error(errorData.detail || `HTTP error! status: ${response.status}`);\n      }\n      const result = await response.json();\n      return result.results || [];\n    } catch (error) {\n      console.error('Book search failed:', error);\n      throw error;\n    }\n  }\n\n  /**\n   * Connect to real-time progress updates using Server-Sent Events\n   */\n  connectToProgress(taskId, onProgress) {\n    const eventSource = new EventSource(`${this.baseUrl}/api/progress/${taskId}`);\n    eventSource.onmessage = event => {\n      try {\n        const data = JSON.parse(event.data);\n        onProgress(data);\n      } catch (error) {\n        console.error('Failed to parse progress data:', error);\n      }\n    };\n    eventSource.onerror = error => {\n      console.error('Progress stream error:', error);\n      eventSource.close();\n    };\n    return eventSource;\n  }\n\n  /**\n   * Get the current API status\n   */\n  getApiStatus() {\n    return {\n      baseUrl: this.baseUrl,\n      isAvailable: false // Will be updated by health check\n    };\n  }\n}\n\n// Create and export a singleton instance\nexport const apiService = new ApiService();\n\n// Export the class for testing\nexport { ApiService };","map":{"version":3,"names":["API_BASE_URL","process","env","REACT_APP_API_URL","ApiService","constructor","baseUrl","checkHealth","response","fetch","ok","Error","status","json","error","console","testConnection","file","log","formData","FormData","append","method","body","statusText","result","processImage","name","size","type","errorData","detail","spine_regions","convertedResult","image_url","URL","createObjectURL","total_spines","successful_matches","perfect_matches","map","spine","bbox","x","y","width","height","rotation","length","xCoords","yCoords","Math","min","max","dx","dy","atan2","PI","convertedSpine","id","confidence","coordinates","ocr_text","denoised_text","book_matches","match","spine_id","random","title","author_name","author","first_publish_year","year","parseInt","publisher","match_score","match_type","spine_region_id","open_library_id","ocr_failures","failure","error_type","message","processing_time","searchBooks","query","limit","encodeURIComponent","results","connectToProgress","taskId","onProgress","eventSource","EventSource","onmessage","event","data","JSON","parse","onerror","close","getApiStatus","isAvailable","apiService"],"sources":["C:/Users/coope/CursorWorkspace/Spinecat/web_interface/src/services/api.ts"],"sourcesContent":["import { ProcessingResult, OpenLibraryBook } from '../types';\n\nconst API_BASE_URL = process.env.REACT_APP_API_URL || 'http://localhost:8000';\n\nclass ApiService {\n  private baseUrl: string;\n\n  constructor() {\n    this.baseUrl = 'http://127.0.0.1:8002'; // Updated to use port 8002\n  }\n\n  /**\n   * Check if the backend is healthy and ready\n   */\n  async checkHealth(): Promise<{ status: string; pipeline: string }> {\n    try {\n      const response = await fetch(`${this.baseUrl}/health`);\n      if (!response.ok) {\n        throw new Error(`HTTP error! status: ${response.status}`);\n      }\n      return await response.json();\n    } catch (error) {\n      console.error('Health check failed:', error);\n      throw new Error('Backend is not available');\n    }\n  }\n\n  /**\n   * Test API connectivity\n   */\n  async testConnection(file: File): Promise<any> {\n    try {\n      console.log('ðŸ§ª API: Testing connection...');\n      const formData = new FormData();\n      formData.append('file', file);\n\n      const response = await fetch(`${this.baseUrl}/api/test`, {\n        method: 'POST',\n        body: formData,\n      });\n\n      console.log('ðŸ§ª API: Test response:', response.status, response.statusText);\n      \n      if (!response.ok) {\n        throw new Error(`Test failed! status: ${response.status}`);\n      }\n\n      const result = await response.json();\n      console.log('ðŸ§ª API: Test result:', result);\n      return result;\n    } catch (error) {\n      console.error('ðŸ§ª API: Test failed:', error);\n      throw error;\n    }\n  }\n\n  /**\n   * Process an uploaded image through the Spinecat pipeline\n   */\n  async processImage(file: File): Promise<ProcessingResult> {\n    try {\n      console.log('ðŸš€ API: Starting processImage...');\n      console.log('ðŸš€ API: baseUrl:', this.baseUrl);\n      console.log('ðŸš€ API: file:', file.name, file.size, file.type);\n      \n      const formData = new FormData();\n      formData.append('file', file);\n\n      console.log('ðŸš€ API: Making fetch request to:', `${this.baseUrl}/api/process-image`);\n      const response = await fetch(`${this.baseUrl}/api/process-image`, {\n        method: 'POST',\n        body: formData,\n      });\n      \n      console.log('ðŸš€ API: Response received:', response.status, response.statusText);\n\n      if (!response.ok) {\n        const errorData = await response.json();\n        throw new Error(errorData.detail || `HTTP error! status: ${response.status}`);\n      }\n\n      const result = await response.json();\n      \n      // Debug logging\n      console.log('Backend API response:', result);\n      console.log('Spine regions from backend:', result.spine_regions);\n      \n      // Convert the API response to our frontend types\n      const convertedResult = {\n        image_url: URL.createObjectURL(file),\n        total_spines: result.total_spines,\n        successful_matches: result.successful_matches,\n        perfect_matches: result.successful_matches,\n        spine_regions: result.spine_regions.map((spine: any) => {\n          // Debug logging for each spine\n          console.log('Processing spine:', spine);\n          console.log('Spine bbox:', spine.bbox);\n          \n          const bbox = spine.bbox || [];\n          let x = 0, y = 0, width = 0, height = 0, rotation = 0;\n          \n          if (bbox.length >= 8) {\n            const xCoords = [bbox[0], bbox[2], bbox[4], bbox[6]];\n            const yCoords = [bbox[1], bbox[3], bbox[5], bbox[7]];\n            x = Math.min(...xCoords);\n            y = Math.min(...yCoords);\n            width = Math.max(...xCoords) - x;\n            height = Math.max(...yCoords) - y;\n            \n            if (bbox.length >= 4) {\n              const dx = bbox[2] - bbox[0];\n              const dy = bbox[3] - bbox[1];\n              rotation = Math.atan2(dy, dx) * (180 / Math.PI);\n            }\n            \n            console.log('Converted coordinates:', { x, y, width, height, rotation });\n          } else {\n            console.log('Invalid bbox length:', bbox.length);\n          }\n          \n          const convertedSpine = {\n            id: spine.id,\n            x: x,\n            y: y,\n            width: width,\n            height: height,\n            rotation: rotation,\n            confidence: spine.confidence,\n            coordinates: bbox.length >= 8 ? [\n              [bbox[0], bbox[1]], [bbox[2], bbox[3]], \n              [bbox[4], bbox[5]], [bbox[6], bbox[7]]\n            ] : [],\n            ocr_text: spine.ocr_text || \"No OCR text available\",\n            denoised_text: spine.denoised_text || \"No denoised text available\",\n          };\n          \n          console.log('Converted spine:', convertedSpine);\n          return convertedSpine;\n        }),\n        book_matches: result.book_matches.map((match: any) => ({\n          id: match.spine_id || `match_${Math.random()}`,\n          title: match.title || \"\",\n          author_name: match.author ? [match.author] : [],\n          first_publish_year: match.year ? parseInt(match.year) : null,\n          publisher: \"\",\n          match_score: match.confidence || 0,\n          match_type: match.confidence > 0.8 ? 'exact' : match.confidence > 0.6 ? 'strong' : match.confidence > 0.4 ? 'moderate' : 'weak',\n          confidence: match.confidence || 0,\n          ocr_text: match.ocr_text || \"No OCR text available\",\n          spine_region_id: match.spine_id || \"\",\n          open_library_id: match.open_library_id || \"\",\n        })),\n        ocr_failures: result.ocr_failures.map((failure: any) => ({\n          id: failure.spine_id,\n          spine_id: failure.spine_id,\n          bbox: failure.bbox,\n          confidence: failure.confidence,\n          error_type: failure.error_type || \"no_text_detected\",\n          message: failure.message || \"No text could be extracted from this spine region\"\n        })),\n        processing_time: result.processing_time,\n      };\n      \n      // Debug logging for final result\n      console.log('Final converted spine regions:', convertedResult.spine_regions.map((spine: any) => ({\n        id: spine.id,\n        x: spine.x,\n        y: spine.y,\n        width: spine.width,\n        height: spine.height\n      })));\n      \n      return convertedResult;\n    } catch (error) {\n      console.error('Image processing failed:', error);\n      throw error;\n    }\n  }\n\n  /**\n   * Search for books using the Open Library API\n   */\n  async searchBooks(query: string, limit: number = 5): Promise<OpenLibraryBook[]> {\n    try {\n      const response = await fetch(\n        `${this.baseUrl}/api/search-books?query=${encodeURIComponent(query)}&limit=${limit}`\n      );\n\n      if (!response.ok) {\n        const errorData = await response.json();\n        throw new Error(errorData.detail || `HTTP error! status: ${response.status}`);\n      }\n\n      const result = await response.json();\n      return result.results || [];\n    } catch (error) {\n      console.error('Book search failed:', error);\n      throw error;\n    }\n  }\n\n  /**\n   * Connect to real-time progress updates using Server-Sent Events\n   */\n  connectToProgress(taskId: string, onProgress: (data: any) => void): EventSource {\n    const eventSource = new EventSource(`${this.baseUrl}/api/progress/${taskId}`);\n    \n    eventSource.onmessage = (event) => {\n      try {\n        const data = JSON.parse(event.data);\n        onProgress(data);\n      } catch (error) {\n        console.error('Failed to parse progress data:', error);\n      }\n    };\n    \n    eventSource.onerror = (error) => {\n      console.error('Progress stream error:', error);\n      eventSource.close();\n    };\n    \n    return eventSource;\n  }\n\n  /**\n   * Get the current API status\n   */\n  getApiStatus(): { baseUrl: string; isAvailable: boolean } {\n    return {\n      baseUrl: this.baseUrl,\n      isAvailable: false, // Will be updated by health check\n    };\n  }\n}\n\n// Create and export a singleton instance\nexport const apiService = new ApiService();\n\n// Export the class for testing\nexport { ApiService };\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}