{"ast":null,"code":"export class ApiService {\n  constructor() {\n    this.baseUrl = void 0;\n    this.baseUrl = 'http://127.0.0.1:8002';\n  }\n\n  // Public getter for base URL\n  getBaseUrl() {\n    return this.baseUrl;\n  }\n\n  /**\n   * Test API connection\n   */\n  async testConnection() {\n    try {\n      console.log('üß™ API: Testing connection...');\n      const response = await fetch(`${this.baseUrl}/api/test`, {\n        method: 'POST',\n        body: new FormData()\n      });\n      console.log('üß™ API: Test response:', response.status, response.statusText);\n      if (!response.ok) {\n        throw new Error(`HTTP error! status: ${response.status}`);\n      }\n      const result = await response.json();\n      console.log('üß™ API: Test result:', result);\n      return result;\n    } catch (error) {\n      console.error('‚ùå API: Connection test failed:', error);\n      throw error;\n    }\n  }\n\n  /**\n   * Start image processing - returns task_id\n   */\n  async startProcess(file) {\n    try {\n      console.log('üöÄ API: Starting processImage...');\n      console.log('üöÄ API: baseUrl:', this.baseUrl);\n      console.log('üöÄ API: file:', file.name, file.size, file.type);\n      const formData = new FormData();\n      formData.append('file', file);\n      console.log('üöÄ API: Making fetch request to:', `${this.baseUrl}/api/process-image`);\n      const response = await fetch(`${this.baseUrl}/api/process-image`, {\n        method: 'POST',\n        body: formData\n      });\n      if (!response.ok) {\n        throw new Error(`HTTP error! status: ${response.status}`);\n      }\n      const result = await response.json();\n      console.log('‚úÖ API: Process started successfully:', result);\n      return result;\n    } catch (error) {\n      console.error('‚ùå API: Failed to start process:', error);\n      throw error;\n    }\n  }\n\n  /**\n   * Get progress for a specific task\n   */\n  async getProgress(taskId) {\n    try {\n      const response = await fetch(`${this.baseUrl}/api/progress/${taskId}`);\n      if (!response.ok) {\n        throw new Error(`HTTP error! status: ${response.status}`);\n      }\n      return await response.json();\n    } catch (error) {\n      console.error('Failed to get progress:', error);\n      throw error;\n    }\n  }\n\n  /**\n   * Get result for a completed task\n   */\n  async getResult(taskId) {\n    try {\n      const response = await fetch(`${this.baseUrl}/api/result/${taskId}`);\n      if (!response.ok) {\n        throw new Error(`HTTP error! status: ${response.status}`);\n      }\n      const data = await response.json();\n      if (data.status !== 'completed') {\n        throw new Error(`Task not completed: ${data.status}`);\n      }\n      return data;\n    } catch (error) {\n      console.error('Failed to get result:', error);\n      throw error;\n    }\n  }\n\n  /**\n   * Search for books\n   */\n  async searchBooks(query, limit = 5) {\n    try {\n      const response = await fetch(`${this.baseUrl}/api/search-books?query=${encodeURIComponent(query)}&limit=${limit}`);\n      if (!response.ok) {\n        throw new Error(`HTTP error! status: ${response.status}`);\n      }\n      const data = await response.json();\n\n      // Handle the structured response from backend\n      if (data.success && Array.isArray(data.results)) {\n        return data.results;\n      } else if (Array.isArray(data)) {\n        // Fallback: if backend returns array directly\n        return data;\n      } else {\n        console.warn('Unexpected search response format:', data);\n        return [];\n      }\n    } catch (error) {\n      console.error('Failed to search books:', error);\n      return [];\n    }\n  }\n}\nexport const apiService = new ApiService();","map":{"version":3,"names":["ApiService","constructor","baseUrl","getBaseUrl","testConnection","console","log","response","fetch","method","body","FormData","status","statusText","ok","Error","result","json","error","startProcess","file","name","size","type","formData","append","getProgress","taskId","getResult","data","searchBooks","query","limit","encodeURIComponent","success","Array","isArray","results","warn","apiService"],"sources":["/Users/cooperstevens/Documents/CursorWorkspace copy/Spinecat/web_interface/src/services/api.ts"],"sourcesContent":["import { ProcessingResult, OpenLibraryBook } from '../types';\n\nexport class ApiService {\n  private baseUrl: string;\n\n  constructor() {\n    this.baseUrl = 'http://127.0.0.1:8002';\n  }\n\n  // Public getter for base URL\n  public getBaseUrl(): string {\n    return this.baseUrl;\n  }\n\n  /**\n   * Test API connection\n   */\n  async testConnection(): Promise<{ status: string; filename: string; size: number }> {\n    try {\n      console.log('üß™ API: Testing connection...');\n      const response = await fetch(`${this.baseUrl}/api/test`, {\n        method: 'POST',\n        body: new FormData()\n      });\n      \n      console.log('üß™ API: Test response:', response.status, response.statusText);\n      \n      if (!response.ok) {\n        throw new Error(`HTTP error! status: ${response.status}`);\n      }\n      \n      const result = await response.json();\n      console.log('üß™ API: Test result:', result);\n      return result;\n    } catch (error) {\n      console.error('‚ùå API: Connection test failed:', error);\n      throw error;\n    }\n  }\n\n  /**\n   * Start image processing - returns task_id\n   */\n  async startProcess(file: File): Promise<{ task_id: string }> {\n    try {\n      console.log('üöÄ API: Starting processImage...');\n      console.log('üöÄ API: baseUrl:', this.baseUrl);\n      console.log('üöÄ API: file:', file.name, file.size, file.type);\n      \n      const formData = new FormData();\n      formData.append('file', file);\n      \n      console.log('üöÄ API: Making fetch request to:', `${this.baseUrl}/api/process-image`);\n      \n      const response = await fetch(`${this.baseUrl}/api/process-image`, {\n        method: 'POST',\n        body: formData,\n      });\n      \n      if (!response.ok) {\n        throw new Error(`HTTP error! status: ${response.status}`);\n      }\n      \n      const result = await response.json();\n      console.log('‚úÖ API: Process started successfully:', result);\n      return result;\n    } catch (error) {\n      console.error('‚ùå API: Failed to start process:', error);\n      throw error;\n    }\n  }\n\n  /**\n   * Get progress for a specific task\n   */\n  async getProgress(taskId: string): Promise<{ status: string; progress: number; message: string }> {\n    try {\n      const response = await fetch(`${this.baseUrl}/api/progress/${taskId}`);\n      if (!response.ok) {\n        throw new Error(`HTTP error! status: ${response.status}`);\n      }\n      return await response.json();\n    } catch (error) {\n      console.error('Failed to get progress:', error);\n      throw error;\n    }\n  }\n\n  /**\n   * Get result for a completed task\n   */\n  async getResult(taskId: string): Promise<ProcessingResult> {\n    try {\n      const response = await fetch(`${this.baseUrl}/api/result/${taskId}`);\n      if (!response.ok) {\n        throw new Error(`HTTP error! status: ${response.status}`);\n      }\n      const data = await response.json();\n      if (data.status !== 'completed') {\n        throw new Error(`Task not completed: ${data.status}`);\n      }\n      return data;\n    } catch (error) {\n      console.error('Failed to get result:', error);\n      throw error;\n    }\n  }\n\n  /**\n   * Search for books\n   */\n  async searchBooks(query: string, limit: number = 5): Promise<OpenLibraryBook[]> {\n    try {\n      const response = await fetch(`${this.baseUrl}/api/search-books?query=${encodeURIComponent(query)}&limit=${limit}`);\n      if (!response.ok) {\n        throw new Error(`HTTP error! status: ${response.status}`);\n      }\n      const data = await response.json();\n      \n      // Handle the structured response from backend\n      if (data.success && Array.isArray(data.results)) {\n        return data.results;\n      } else if (Array.isArray(data)) {\n        // Fallback: if backend returns array directly\n        return data;\n      } else {\n        console.warn('Unexpected search response format:', data);\n        return [];\n      }\n    } catch (error) {\n      console.error('Failed to search books:', error);\n      return [];\n    }\n  }\n}\n\nexport const apiService = new ApiService();\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}