{"ast":null,"code":"// Minimum image requirements\nconst MIN_WIDTH=800;const MIN_HEIGHT=600;const MAX_FILE_SIZE=10*1024*1024;// 10MB\n/**\r\n * Validates an uploaded image file\r\n */export async function validateImage(file){const errors=[];const warnings=[];// Check file type\nif(!file.type.startsWith('image/jpeg')){errors.push('Only JPEG images are supported');return{isValid:false,errors,warnings};}// Check file size\nif(file.size>MAX_FILE_SIZE){errors.push(\"File size must be less than \".concat(MAX_FILE_SIZE/(1024*1024),\"MB\"));}// Check image dimensions and quality\ntry{const dimensions=await getImageDimensions(file);if(dimensions.width<MIN_WIDTH||dimensions.height<MIN_HEIGHT){errors.push(\"Image must be at least \".concat(MIN_WIDTH,\"x\").concat(MIN_HEIGHT,\" pixels\"));}// Check aspect ratio (should be reasonable for book spines)\nconst aspectRatio=dimensions.width/dimensions.height;if(aspectRatio<0.5||aspectRatio>3){warnings.push('Unusual aspect ratio - may affect spine detection accuracy');}// Check for potential blur (simple edge detection simulation)\nconst blurScore=await checkImageBlur(file);if(blurScore<0.3){errors.push('Image appears to be blurry - please use a sharper image');}else if(blurScore<0.6){warnings.push('Image quality could be improved for better results');}}catch(error){errors.push('Failed to analyze image - file may be corrupted');}return{isValid:errors.length===0,errors,warnings};}/**\r\n * Gets image dimensions from a file\r\n */async function getImageDimensions(file){return new Promise((resolve,reject)=>{const img=new Image();img.onload=()=>{resolve({width:img.width,height:img.height});};img.onerror=()=>reject(new Error('Failed to load image'));img.src=URL.createObjectURL(file);});}/**\r\n * Simple blur detection using canvas\r\n */async function checkImageBlur(file){return new Promise(resolve=>{const canvas=document.createElement('canvas');const ctx=canvas.getContext('2d');const img=new Image();img.onload=()=>{canvas.width=img.width;canvas.height=img.height;if(ctx){ctx.drawImage(img,0,0);const imageData=ctx.getImageData(0,0,canvas.width,canvas.height);const blurScore=calculateBlurScore(imageData);resolve(blurScore);}else{resolve(0.5);// Default score if canvas context not available\n}};img.onerror=()=>resolve(0.5);// Default score on error\nimg.src=URL.createObjectURL(file);});}/**\r\n * Calculate blur score using Laplacian variance\r\n */function calculateBlurScore(imageData){const{data,width,height}=imageData;let variance=0;let count=0;// Simple edge detection using Laplacian operator\nfor(let y=1;y<height-1;y++){for(let x=1;x<width-1;x++){const idx=(y*width+x)*4;const center=data[idx];// Laplacian kernel: [[0,1,0], [1,-4,1], [0,1,0]]\nconst laplacian=data[((y-1)*width+x)*4]+// top\ndata[((y+1)*width+x)*4]+// bottom\ndata[(y*width+(x-1))*4]+// left\ndata[(y*width+(x+1))*4]-// right\n4*center;// center * -4\nvariance+=laplacian*laplacian;count++;}}const avgVariance=variance/count;// Normalize to 0-1 range (higher = sharper)\n// This is a simplified approach - in production you'd want more sophisticated blur detection\nconst normalizedScore=Math.min(avgVariance/1000,1.0);return normalizedScore;}/**\r\n * Process image through the Spinecat pipeline\r\n * This will be replaced with actual pipeline integration\r\n */export async function processImage(file){// TODO: Integrate with actual pipeline\n// For now, return a promise that resolves after a delay\nreturn new Promise(resolve=>{setTimeout(()=>{resolve({success:true,message:'Image processed successfully'});},2000);});}","map":{"version":3,"names":["MIN_WIDTH","MIN_HEIGHT","MAX_FILE_SIZE","validateImage","file","errors","warnings","type","startsWith","push","isValid","size","concat","dimensions","getImageDimensions","width","height","aspectRatio","blurScore","checkImageBlur","error","length","Promise","resolve","reject","img","Image","onload","onerror","Error","src","URL","createObjectURL","canvas","document","createElement","ctx","getContext","drawImage","imageData","getImageData","calculateBlurScore","data","variance","count","y","x","idx","center","laplacian","avgVariance","normalizedScore","Math","min","processImage","setTimeout","success","message"],"sources":["C:/Users/coope/CursorWorkspace/Spinecat/web_interface/src/utils/imageUtils.ts"],"sourcesContent":["import { ImageValidationResult } from '../types';\r\n\r\n// Minimum image requirements\r\nconst MIN_WIDTH = 800;\r\nconst MIN_HEIGHT = 600;\r\nconst MAX_FILE_SIZE = 10 * 1024 * 1024; // 10MB\r\n\r\n/**\r\n * Validates an uploaded image file\r\n */\r\nexport async function validateImage(file: File): Promise<ImageValidationResult> {\r\n  const errors: string[] = [];\r\n  const warnings: string[] = [];\r\n\r\n  // Check file type\r\n  if (!file.type.startsWith('image/jpeg')) {\r\n    errors.push('Only JPEG images are supported');\r\n    return { isValid: false, errors, warnings };\r\n  }\r\n\r\n  // Check file size\r\n  if (file.size > MAX_FILE_SIZE) {\r\n    errors.push(`File size must be less than ${MAX_FILE_SIZE / (1024 * 1024)}MB`);\r\n  }\r\n\r\n  // Check image dimensions and quality\r\n  try {\r\n    const dimensions = await getImageDimensions(file);\r\n    \r\n    if (dimensions.width < MIN_WIDTH || dimensions.height < MIN_HEIGHT) {\r\n      errors.push(`Image must be at least ${MIN_WIDTH}x${MIN_HEIGHT} pixels`);\r\n    }\r\n\r\n    // Check aspect ratio (should be reasonable for book spines)\r\n    const aspectRatio = dimensions.width / dimensions.height;\r\n    if (aspectRatio < 0.5 || aspectRatio > 3) {\r\n      warnings.push('Unusual aspect ratio - may affect spine detection accuracy');\r\n    }\r\n\r\n    // Check for potential blur (simple edge detection simulation)\r\n    const blurScore = await checkImageBlur(file);\r\n    if (blurScore < 0.3) {\r\n      errors.push('Image appears to be blurry - please use a sharper image');\r\n    } else if (blurScore < 0.6) {\r\n      warnings.push('Image quality could be improved for better results');\r\n    }\r\n\r\n  } catch (error) {\r\n    errors.push('Failed to analyze image - file may be corrupted');\r\n  }\r\n\r\n  return {\r\n    isValid: errors.length === 0,\r\n    errors,\r\n    warnings\r\n  };\r\n}\r\n\r\n/**\r\n * Gets image dimensions from a file\r\n */\r\nasync function getImageDimensions(file: File): Promise<{ width: number; height: number }> {\r\n  return new Promise((resolve, reject) => {\r\n    const img = new Image();\r\n    img.onload = () => {\r\n      resolve({ width: img.width, height: img.height });\r\n    };\r\n    img.onerror = () => reject(new Error('Failed to load image'));\r\n    img.src = URL.createObjectURL(file);\r\n  });\r\n}\r\n\r\n/**\r\n * Simple blur detection using canvas\r\n */\r\nasync function checkImageBlur(file: File): Promise<number> {\r\n  return new Promise((resolve) => {\r\n    const canvas = document.createElement('canvas');\r\n    const ctx = canvas.getContext('2d');\r\n    const img = new Image();\r\n    \r\n    img.onload = () => {\r\n      canvas.width = img.width;\r\n      canvas.height = img.height;\r\n      \r\n      if (ctx) {\r\n        ctx.drawImage(img, 0, 0);\r\n        const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);\r\n        const blurScore = calculateBlurScore(imageData);\r\n        resolve(blurScore);\r\n      } else {\r\n        resolve(0.5); // Default score if canvas context not available\r\n      }\r\n    };\r\n    \r\n    img.onerror = () => resolve(0.5); // Default score on error\r\n    img.src = URL.createObjectURL(file);\r\n  });\r\n}\r\n\r\n/**\r\n * Calculate blur score using Laplacian variance\r\n */\r\nfunction calculateBlurScore(imageData: ImageData): number {\r\n  const { data, width, height } = imageData;\r\n  let variance = 0;\r\n  let count = 0;\r\n\r\n  // Simple edge detection using Laplacian operator\r\n  for (let y = 1; y < height - 1; y++) {\r\n    for (let x = 1; x < width - 1; x++) {\r\n      const idx = (y * width + x) * 4;\r\n      const center = data[idx];\r\n      \r\n      // Laplacian kernel: [[0,1,0], [1,-4,1], [0,1,0]]\r\n      const laplacian = \r\n        data[((y-1) * width + x) * 4] +     // top\r\n        data[((y+1) * width + x) * 4] +     // bottom\r\n        data[(y * width + (x-1)) * 4] +     // left\r\n        data[(y * width + (x+1)) * 4] -     // right\r\n        4 * center;                          // center * -4\r\n      \r\n      variance += laplacian * laplacian;\r\n      count++;\r\n    }\r\n  }\r\n\r\n  const avgVariance = variance / count;\r\n  \r\n  // Normalize to 0-1 range (higher = sharper)\r\n  // This is a simplified approach - in production you'd want more sophisticated blur detection\r\n  const normalizedScore = Math.min(avgVariance / 1000, 1.0);\r\n  \r\n  return normalizedScore;\r\n}\r\n\r\n/**\r\n * Process image through the Spinecat pipeline\r\n * This will be replaced with actual pipeline integration\r\n */\r\nexport async function processImage(file: File): Promise<any> {\r\n  // TODO: Integrate with actual pipeline\r\n  // For now, return a promise that resolves after a delay\r\n  return new Promise((resolve) => {\r\n    setTimeout(() => {\r\n      resolve({\r\n        success: true,\r\n        message: 'Image processed successfully'\r\n      });\r\n    }, 2000);\r\n  });\r\n}\r\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}