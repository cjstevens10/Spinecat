{"ast":null,"code":"// Minimum image requirements\nconst MIN_WIDTH = 800;\nconst MIN_HEIGHT = 600;\nconst MAX_FILE_SIZE = 10 * 1024 * 1024; // 10MB\n\n/**\n * Validates an uploaded image file\n */\nexport async function validateImage(file) {\n  const errors = [];\n  const warnings = [];\n\n  // Check file type\n  if (!file.type.startsWith('image/jpeg')) {\n    errors.push('Only JPEG images are supported');\n    return {\n      isValid: false,\n      errors,\n      warnings\n    };\n  }\n\n  // Check file size\n  if (file.size > MAX_FILE_SIZE) {\n    errors.push(`File size must be less than ${MAX_FILE_SIZE / (1024 * 1024)}MB`);\n  }\n\n  // Check image dimensions and quality\n  try {\n    const dimensions = await getImageDimensions(file);\n    if (dimensions.width < MIN_WIDTH || dimensions.height < MIN_HEIGHT) {\n      errors.push(`Image must be at least ${MIN_WIDTH}x${MIN_HEIGHT} pixels`);\n    }\n\n    // Check aspect ratio (should be reasonable for book spines)\n    const aspectRatio = dimensions.width / dimensions.height;\n    if (aspectRatio < 0.5 || aspectRatio > 3) {\n      warnings.push('Unusual aspect ratio - may affect spine detection accuracy');\n    }\n\n    // Check for potential blur (simple edge detection simulation)\n    const blurScore = await checkImageBlur(file);\n    if (blurScore < 0.1) {\n      errors.push('Image appears to be very blurry - please use a sharper image for best results');\n    } else if (blurScore < 0.3) {\n      warnings.push('Image quality could be improved, but should still work');\n    }\n  } catch (error) {\n    errors.push('Failed to analyze image - file may be corrupted');\n  }\n  return {\n    isValid: errors.length === 0,\n    errors,\n    warnings\n  };\n}\n\n/**\n * Gets image dimensions from a file\n */\nasync function getImageDimensions(file) {\n  return new Promise((resolve, reject) => {\n    const img = new Image();\n    img.onload = () => {\n      resolve({\n        width: img.width,\n        height: img.height\n      });\n    };\n    img.onerror = () => reject(new Error('Failed to load image'));\n    img.src = URL.createObjectURL(file);\n  });\n}\n\n/**\n * Simple blur detection using canvas\n */\nasync function checkImageBlur(file) {\n  return new Promise(resolve => {\n    const canvas = document.createElement('canvas');\n    const ctx = canvas.getContext('2d');\n    const img = new Image();\n    img.onload = () => {\n      canvas.width = img.width;\n      canvas.height = img.height;\n      if (ctx) {\n        ctx.drawImage(img, 0, 0);\n        const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);\n        const blurScore = calculateBlurScore(imageData);\n        resolve(blurScore);\n      } else {\n        resolve(0.5); // Default score if canvas context not available\n      }\n    };\n    img.onerror = () => resolve(0.5); // Default score on error\n    img.src = URL.createObjectURL(file);\n  });\n}\n\n/**\n * Calculate blur score using Laplacian variance\n */\nfunction calculateBlurScore(imageData) {\n  const {\n    data,\n    width,\n    height\n  } = imageData;\n  let variance = 0;\n  let count = 0;\n\n  // Simple edge detection using Laplacian operator\n  for (let y = 1; y < height - 1; y++) {\n    for (let x = 1; x < width - 1; x++) {\n      const idx = (y * width + x) * 4;\n      const center = data[idx];\n\n      // Laplacian kernel: [[0,1,0], [1,-4,1], [0,1,0]]\n      const laplacian = data[((y - 1) * width + x) * 4] +\n      // top\n      data[((y + 1) * width + x) * 4] +\n      // bottom\n      data[(y * width + (x - 1)) * 4] +\n      // left\n      data[(y * width + (x + 1)) * 4] -\n      // right\n      4 * center; // center * -4\n\n      variance += laplacian * laplacian;\n      count++;\n    }\n  }\n  const avgVariance = variance / count;\n\n  // Normalize to 0-1 range (higher = sharper)\n  // This is a simplified approach - in production you'd want more sophisticated blur detection\n  let normalizedScore = Math.min(avgVariance / 500, 1.0);\n\n  // Ensure minimum score for images that might have low variance but are still sharp\n  // This prevents false rejections of good quality images\n  normalizedScore = Math.max(normalizedScore, 0.2);\n  return normalizedScore;\n}\n\n/**\n * Process image through the Spinecat pipeline\n * This will be replaced with actual pipeline integration\n */\nexport async function processImage(file) {\n  // TODO: Integrate with actual pipeline\n  // For now, return a promise that resolves after a delay\n  return new Promise(resolve => {\n    setTimeout(() => {\n      resolve({\n        success: true,\n        message: 'Image processed successfully'\n      });\n    }, 2000);\n  });\n}","map":{"version":3,"names":["MIN_WIDTH","MIN_HEIGHT","MAX_FILE_SIZE","validateImage","file","errors","warnings","type","startsWith","push","isValid","size","dimensions","getImageDimensions","width","height","aspectRatio","blurScore","checkImageBlur","error","length","Promise","resolve","reject","img","Image","onload","onerror","Error","src","URL","createObjectURL","canvas","document","createElement","ctx","getContext","drawImage","imageData","getImageData","calculateBlurScore","data","variance","count","y","x","idx","center","laplacian","avgVariance","normalizedScore","Math","min","max","processImage","setTimeout","success","message"],"sources":["C:/Users/coope/CursorWorkspace/Spinecat/web_interface/src/utils/imageUtils.ts"],"sourcesContent":["import { ImageValidationResult } from '../types';\n\n// Minimum image requirements\nconst MIN_WIDTH = 800;\nconst MIN_HEIGHT = 600;\nconst MAX_FILE_SIZE = 10 * 1024 * 1024; // 10MB\n\n/**\n * Validates an uploaded image file\n */\nexport async function validateImage(file: File): Promise<ImageValidationResult> {\n  const errors: string[] = [];\n  const warnings: string[] = [];\n\n  // Check file type\n  if (!file.type.startsWith('image/jpeg')) {\n    errors.push('Only JPEG images are supported');\n    return { isValid: false, errors, warnings };\n  }\n\n  // Check file size\n  if (file.size > MAX_FILE_SIZE) {\n    errors.push(`File size must be less than ${MAX_FILE_SIZE / (1024 * 1024)}MB`);\n  }\n\n  // Check image dimensions and quality\n  try {\n    const dimensions = await getImageDimensions(file);\n    \n    if (dimensions.width < MIN_WIDTH || dimensions.height < MIN_HEIGHT) {\n      errors.push(`Image must be at least ${MIN_WIDTH}x${MIN_HEIGHT} pixels`);\n    }\n\n    // Check aspect ratio (should be reasonable for book spines)\n    const aspectRatio = dimensions.width / dimensions.height;\n    if (aspectRatio < 0.5 || aspectRatio > 3) {\n      warnings.push('Unusual aspect ratio - may affect spine detection accuracy');\n    }\n\n    // Check for potential blur (simple edge detection simulation)\n    const blurScore = await checkImageBlur(file);\n    if (blurScore < 0.1) {\n      errors.push('Image appears to be very blurry - please use a sharper image for best results');\n    } else if (blurScore < 0.3) {\n      warnings.push('Image quality could be improved, but should still work');\n    }\n\n  } catch (error) {\n    errors.push('Failed to analyze image - file may be corrupted');\n  }\n\n  return {\n    isValid: errors.length === 0,\n    errors,\n    warnings\n  };\n}\n\n/**\n * Gets image dimensions from a file\n */\nasync function getImageDimensions(file: File): Promise<{ width: number; height: number }> {\n  return new Promise((resolve, reject) => {\n    const img = new Image();\n    img.onload = () => {\n      resolve({ width: img.width, height: img.height });\n    };\n    img.onerror = () => reject(new Error('Failed to load image'));\n    img.src = URL.createObjectURL(file);\n  });\n}\n\n/**\n * Simple blur detection using canvas\n */\nasync function checkImageBlur(file: File): Promise<number> {\n  return new Promise((resolve) => {\n    const canvas = document.createElement('canvas');\n    const ctx = canvas.getContext('2d');\n    const img = new Image();\n    \n    img.onload = () => {\n      canvas.width = img.width;\n      canvas.height = img.height;\n      \n      if (ctx) {\n        ctx.drawImage(img, 0, 0);\n        const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);\n        const blurScore = calculateBlurScore(imageData);\n        resolve(blurScore);\n      } else {\n        resolve(0.5); // Default score if canvas context not available\n      }\n    };\n    \n    img.onerror = () => resolve(0.5); // Default score on error\n    img.src = URL.createObjectURL(file);\n  });\n}\n\n/**\n * Calculate blur score using Laplacian variance\n */\nfunction calculateBlurScore(imageData: ImageData): number {\n  const { data, width, height } = imageData;\n  let variance = 0;\n  let count = 0;\n\n  // Simple edge detection using Laplacian operator\n  for (let y = 1; y < height - 1; y++) {\n    for (let x = 1; x < width - 1; x++) {\n      const idx = (y * width + x) * 4;\n      const center = data[idx];\n      \n      // Laplacian kernel: [[0,1,0], [1,-4,1], [0,1,0]]\n      const laplacian = \n        data[((y-1) * width + x) * 4] +     // top\n        data[((y+1) * width + x) * 4] +     // bottom\n        data[(y * width + (x-1)) * 4] +     // left\n        data[(y * width + (x+1)) * 4] -     // right\n        4 * center;                          // center * -4\n      \n      variance += laplacian * laplacian;\n      count++;\n    }\n  }\n\n  const avgVariance = variance / count;\n  \n  // Normalize to 0-1 range (higher = sharper)\n  // This is a simplified approach - in production you'd want more sophisticated blur detection\n  let normalizedScore = Math.min(avgVariance / 500, 1.0);\n  \n  // Ensure minimum score for images that might have low variance but are still sharp\n  // This prevents false rejections of good quality images\n  normalizedScore = Math.max(normalizedScore, 0.2);\n  \n  return normalizedScore;\n}\n\n/**\n * Process image through the Spinecat pipeline\n * This will be replaced with actual pipeline integration\n */\nexport async function processImage(file: File): Promise<any> {\n  // TODO: Integrate with actual pipeline\n  // For now, return a promise that resolves after a delay\n  return new Promise((resolve) => {\n    setTimeout(() => {\n      resolve({\n        success: true,\n        message: 'Image processed successfully'\n      });\n    }, 2000);\n  });\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}